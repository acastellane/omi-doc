{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OMI Overview OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories: https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design","title":"Overview"},{"location":"#omi-overview","text":"OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories: https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design","title":"OMI Overview"},{"location":"blocs/apollo/","text":"Apollo Description Description This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"Apollo Description"},{"location":"blocs/apollo/#apollo-description","text":"","title":"Apollo Description"},{"location":"blocs/apollo/#description","text":"This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"Description"},{"location":"blocs/enablement/","text":"OMI ENABLEMENT Guide HARDWARE DESCRIPTION For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an omi host FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMM modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (the latter being under development) Python source code is available at : Python Code Python code documentation is available at : Python Documentation Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) !!! Note The Raspberry pi can host an Cronus server, should you want to evaluate in a Cronus environment. REQUIREMENTS Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx An adapter board from Tormem At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (will be included in adapter board version 2) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth). ENABLEMENT STEPS git clone the \" no-encrypt_vcu128 \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Check Python code documentation at : Python Documentation for further experiments.","title":"FMC+ ENABLEMENT Description"},{"location":"blocs/enablement/#omi-enablement-guide","text":"","title":"OMI ENABLEMENT Guide"},{"location":"blocs/enablement/#hardware-description","text":"For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an omi host FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMM modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (the latter being under development) Python source code is available at : Python Code Python code documentation is available at : Python Documentation Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) !!! Note The Raspberry pi can host an Cronus server, should you want to evaluate in a Cronus environment.","title":"HARDWARE DESCRIPTION"},{"location":"blocs/enablement/#requirements","text":"Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx An adapter board from Tormem At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (will be included in adapter board version 2) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth).","title":"REQUIREMENTS"},{"location":"blocs/enablement/#enablement-steps","text":"git clone the \" no-encrypt_vcu128 \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Check Python code documentation at : Python Documentation for further experiments.","title":"ENABLEMENT STEPS"},{"location":"blocs/fire/","text":"FIRE Description Description Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" no-encrypt_vcu128 \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"FIRE Description"},{"location":"blocs/fire/#fire-description","text":"","title":"FIRE Description"},{"location":"blocs/fire/#description","text":"Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" no-encrypt_vcu128 \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"Description"},{"location":"blocs/gemini/","text":"Gemini Description Description Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"GEMINI Description"},{"location":"blocs/gemini/#gemini-description","text":"","title":"Gemini Description"},{"location":"blocs/gemini/#description","text":"Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/ice/","text":"ICE Description Description Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"ICE Description"},{"location":"blocs/ice/#ice-description","text":"","title":"ICE Description"},{"location":"blocs/ice/#description","text":"Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/python/","text":"Python Enablement Software Description Architecture Details OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development) Requirements \"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here General Preparation and Settings This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required Adapter card Mux settings To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath Initialize device Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init Host/device information To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice Reseting Device Change reset state of a DDIMM or multiple DDIMMs from fire: python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode Example python3 omi.py ddimmreset -d ab -s on Read a host/device register: python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811 Write to a host/device register: python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f Trigger training/synchronisation procedure: python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab To check DDIMM training state: python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab Examples of Usage python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a Sync DDIMMA... DDIMMA sync: 0x8080030000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Python Enablement Software Description"},{"location":"blocs/python/#python-enablement-software-description","text":"","title":"Python Enablement Software Description"},{"location":"blocs/python/#architecture-details","text":"OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development)","title":"Architecture Details"},{"location":"blocs/python/#requirements","text":"\"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here","title":"Requirements"},{"location":"blocs/python/#general-preparation-and-settings","text":"This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required","title":"General Preparation and Settings"},{"location":"blocs/python/#adapter-card-mux-settings","text":"To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath","title":"Adapter card Mux settings"},{"location":"blocs/python/#initialize-device","text":"Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init","title":"Initialize device"},{"location":"blocs/python/#hostdevice-information","text":"To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice","title":"Host/device information"},{"location":"blocs/python/#reseting-device","text":"","title":"Reseting Device"},{"location":"blocs/python/#change-reset-state-of-a-ddimm-or-multiple-ddimms-from-fire","text":"python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode","title":"Change reset state of a DDIMM or multiple DDIMMs from fire:"},{"location":"blocs/python/#example","text":"python3 omi.py ddimmreset -d ab -s on","title":"Example"},{"location":"blocs/python/#read-a-hostdevice-register","text":"python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811","title":"Read a host/device register:"},{"location":"blocs/python/#write-to-a-hostdevice-register","text":"python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f","title":"Write to a host/device register:"},{"location":"blocs/python/#trigger-trainingsynchronisation-procedure","text":"python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab","title":"Trigger training/synchronisation procedure:"},{"location":"blocs/python/#to-check-ddimm-training-state","text":"python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"To check DDIMM training state:"},{"location":"blocs/python/#examples-of-usage","text":"python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a Sync DDIMMA... DDIMMA sync: 0x8080030000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Examples of Usage"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker. 4. Install other optional tools pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics. Website Structure First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Tools to draw diagrams You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker.","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-other-optional-tools","text":"pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics.","title":"4. Install other optional tools"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#tools-to-draw-diagrams","text":"You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Tools to draw diagrams"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Deploy to Github Pages"}]}